function decode_id(key) { return atob(key).slice(key.lastIndexOf("-") + 1) } function save_location(key) { let l; return "c" == atob(key).slice(0, key.lastIndexOf("-")) ? "cloud" : "local" } function get_snippets_data(location) { const list = document.getElementById("tsnip-list"); let s = []; return list.childNodes.forEach(c => { save_location(c.dataset.key) == location && s.push({ key: c.dataset.key, store: c.dataset.store, title: c.innerText }) }), s } function save_to_storage(storageKey) { let s = get_snippets_data("local"); s.length < 1 ? localStorage.removeItem(storageKey) : localStorage.setItem(storageKey, JSON.stringify(s)) }
function ButtonType(type, onclick) { const buttons = document.getElementsByClassName(`tsnip-${type}`); Array.from(buttons).forEach(b => { b.onclick = onclick }), this.setEnabled = enabled => { enabled ? Array.from(buttons).forEach(b => { b.removeAttribute("disabled") }) : Array.from(buttons).forEach(b => { b.setAttribute("disabled", "disabled") }) } }
const notifications = document.getElementById("tsnip-notifications"); function Notification(text, type) { const el = document.createElement("span"); el.innerText = text, ["danger", "warn", "success"].indexOf(type) > -1 && (el.classList = [type]); let delay = null; this.start = duration => { notifications.appendChild(el), null != delay && clearTimeout(delay), delay = setTimeout(() => { notifications.removeChild(el) }, duration || 3e3) } } const saveNotification = new Notification("Saved!", "success"), deleteNotification = new Notification("Deleted.", "danger"), uploadNotification = new Notification("Uploaded!", "success"), signedInNotification = new Notification("Signed in successfully!", "success"), signInErrorNotification = new Notification("Could not sign in.", "warn"), linkCopiedNotification = new Notification("Link copied."), snippetCopiedNotification = new Notification("Snippet copied."), snippetImportedNotification = new Notification("Snippet imported.", "success");
(() => { const list = document.getElementById("tsnip-list"), editor = document.getElementById("tsnip-editor"), storageKey = "tsnip", heartbeat = 1e3; let currentSnip = null; function load_snip(snip) { list.childNodes.forEach(el => { el.classList = [] }), currentSnip = snip, null != snip ? (editor.value = atob(currentSnip.dataset.store), currentSnip.classList = ["current"]) : editor.value = "", autosaveCache = editor.value } function delete_current_snip() { null != currentSnip && list.removeChild(currentSnip), load_snip(null), editor.focus(), enableSnippetButtons(!1) } function save_editor() { if (null == editor.value || "" == editor.value) return delete_current_snip(), -1; const data = btoa(editor.value); if (null != currentSnip) currentSnip.dataset.store = data; else { let title = editor.value.slice(0, 64); title.indexOf("\n") >= 0 && (title = title.slice(0, title.indexOf("\n"))); let nmi = make_li(Date.now(), title, data); list.appendChild(nmi), load_snip(nmi), enableSnippetButtons(!0) } return save_to_storage("tsnip"), 1 } function make_li(id, title, store) { let li = document.createElement("li"); return li.dataset.store = store, li.dataset.key = btoa(`l-${id}`), li.innerText = title, li.contentEditable = !0, li.spellcheck = !1, li.onkeydown = e => { "Enter" != e.key && "Enter" != e.code && "Tab" != e.key && "Tab" != e.code || (e.preventDefault(), save_to_storage("tsnip"), editor.focus()) }, li.onclick = e => { save_editor(), load_snip(li), enableSnippetButtons(!0) }, li } editor.onkeydown = e => { if ("Tab" == e.key || "Tab" == e.code) { e.preventDefault(); let si = editor.selectionStart; editor.value = editor.value.slice(0, si) + "    " + editor.value.slice(si), editor.selectionStart = editor.selectionEnd = si + 4 } }; let autosave = null, autosaveCache = ""; editor.onkeyup = e => { autosaveCache != editor.value && (null != autosave && clearTimeout(autosave), autosave = setTimeout(() => { save_editor() < 0 ? deleteNotification.start() : saveNotification.start(), autosaveCache = editor.value }, 1e3)) }; const newButtons = new ButtonType("new", () => { save_editor(), load_snip(null), enableSnippetButtons(!1) }), deleteButtons = new ButtonType("delete", () => { confirm("Are you sure you want to delete this snippet? This cannot be undone.") ? (delete_current_snip(), deleteNotification.start()) : editor.focus() }), shareButtons = new ButtonType("share", () => { let link = "//" + window.location.host + window.location.pathname; link += "?i=" + btoa(JSON.stringify({ key: currentSnip.dataset.key, store: currentSnip.dataset.store, title: currentSnip.innerText })), navigator.clipboard.writeText(link), linkCopiedNotification.start() }), copyButtons = new ButtonType("copy", () => { navigator.clipboard.writeText(editor.value), snippetCopiedNotification.start() }); function enableSnippetButtons(val) { deleteButtons.setEnabled(val), shareButtons.setEnabled(val), copyButtons.setEnabled(val) } const saved = localStorage.getItem("tsnip"); if (saved) { const jsave = JSON.parse(saved); for (let o of jsave) list.appendChild(make_li(o.key, o.title, o.store)) } const params = new URLSearchParams(window.location.search); if (params.has("i")) { let snip = params.get("i"); if (snip = atob(snip), snip = JSON.parse(snip), snip) { let nli = make_li(snip.key, snip.title + "[imported]", snip.store); list.appendChild(nli), load_snip(nli), enableSnippetButtons(!0), snippetImportedNotification.start() } window.history.replaceState({}, document.title, "//" + window.location.host + window.location.pathname) } })();